<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot面试题</title>
      <link href="/buffifly/2021/07/10/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/buffifly/2021/07/10/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="SpringBoot面试题"><a href="#SpringBoot面试题" class="headerlink" title="SpringBoot面试题"></a>SpringBoot面试题</h2><p><strong><p class='p small'>1、Spring 是什么?</p></strong></p><p class='p small'>Spring 是一个轻量级的 IoC 和 AOP 容器框架。是为 Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的 开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于 XML 的配置、基于注解的配置、基于 Java 的配置。主要由以下几个模块组成：</p><p class='p small'>Spring Core：核心容器，提供 IOC 服务；核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</p><p class='p small'>Spring Context：应用上下文。Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p><p class='p small'>Spring AOP：Spring面向切面编程。通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p><p class='p small'>Spring DAO：JDBC和DAO模块。JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</p><p class='p small'>Spring ORM：对象实体映射。Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事务和DAO异常层次结构。</p><p class='p small'>Spring Web：Web模块。Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><p class='p small'>Spring MVC：MVC模块。MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI、FreeMarker等，模型来有JavaBean来构成，存放于m当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</p><br/><p><strong><p class='p small'>2、Resource 是如何被查找、加载的？</p></strong></p><p class='p small'>Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。 Spring 为 Resource 接口提供了如下实现类：</p><ul><li><p class='p small'>UrlResource：访问网络资源的实现类。</p></li><li><p class='p small'>ClassPathResource：访问类加载路径里资源的实现类。</p></li><li><p class='p small'>FileSystemResource：访问文件系统里资源的实现类。</p></li><li><p class='p small'>ServletContextResource：访问相对于 ServletContext 路径里的资源的实现类</p></li><li><p class='p small'>InputStreamResource：访问输入流资源的实现类。</p></li><li><p class='p small'>ByteArrayResource：访问字节数组资源的实现类。</p></li></ul><p class='p small'>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><br/><p><strong><p class='p small'>3、Spring 的AOP 理解：</p></strong></p><p class='p small'>OOP 面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些不业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系 统的可维护性。可用于权限认证、日志、事务处理。</p><p class='p small'>AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。</p><p class='p small'>（1）AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为编译时增强，他 会在编译阶段将 AspectJ(切面)织入到 Java 字节码中，运行的时候就是增强后的 AOP 对象。</p><p class='p small'>（2）Spring AOP 使用的动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p><strong><p class='p small'>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理：</p></strong></p><p class='p small'>①JDK 动态代理只提供接口的代理，不支持类的代理。核心 InvocationHandler 接口和 Proxy 类，InvocationHandler 通 过 invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy 利用 InvocationHandler 动态创建一个符合某一接口的的实例</p><p class='p small'>②如果代理类没有实现 InvocationHandler接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现 AOP。CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p><p class='p small'>（3）静态代理不动态代理区别在于生成 AOP 代理对象的时机不同，相对来说 AspectJ 的静态代理方式具有更好的性能，但是 AspectJ 需要特定的编译器动行处理，而 Spring AOP 则无需特定的编译器处理。</p><p><strong><p class='p small'>InvocationHandler 的 invoke(Object proxy，Method method，Object[] args)：proxy 是最终生成的代理实例，method 是被代理目 标实例的某个具体方法， args 是被代理目标实例某个方法的具体入参，在方法反射调用时使用。</p></strong></p> <br/><p><strong><p class='p small'>4、Spring 的 IoC 理解：</p></strong></p><p class='p small'>（1）IOC 就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖 IoC容器来动态注入对象需要的外部资源。</p><p class='p small'>（2）最直观的表达就是，IOC 让对象的创建不用去 new 了，可以由 spring 自动生产，使用 java 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p class='p small'>（3）Spring 的 IOC 有三种注入方式 ：极造器注入、setter 方法注入、根据注解注入。</p><p><strong><p class='p small'>IoC 让相互协作的组件保持松散的耦合，而 AOP 编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></strong></p> <br/><p><strong><p class='p small'>5、BeanFactory 和 ApplicationContext 有什么区别？</p></strong></p><p class='p small'>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p><p class='p small'>（1）BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制</p><p class='p small'>bean 的生命周期，维护 bean 之间的依赖关系。ApplicationContext接口作为 BeanFactory 的派生，除了提供BeanFactory 所具有的 功能外，还提供了更完整的框架功能：</p><p class='p small'>①继承 MessageSource，因此支持国际化。</p><p class='p small'>②统一的资源文件访问方式。</p><p class='p small'>③提供在监听器中注册 bean 的事件。</p><p class='p small'>④同时加载多个配置文件。</p><p class='p small'>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都与注于一个特定的层次，比如应用的 web 层。</p><p class='p small'>（2）①BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 动行加载实 例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使 用调用 getBean 方法才会抛出异常。</p><p class='p small'>②ApplicationContext，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的 配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean</p><p class='p small'>③相对于基本的 BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置 Bean较多时，程序启动较慢。</p><p class='p small'>（3）BeanFactory 通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</p><p class='p small'>（4）BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：</p><p><strong><p class='p small'>BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。</p></strong></p><table><thead><tr><th><strong>BeanFactory</strong></th><th><strong>ApplicationContext</strong></th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table> <br/><p><strong><p class='p small'>6、请解释 Spring Bean 的生命周期？</p></strong></p><p class='p small'>1、Bean 容器找到配置文件中 Spring Bean 的定义。</p><p class='p small'>2、Bean 容器利用 Java 反射创建一个Bean的实例。</p><p class='p small'>3、如果涉及到一些属性值 利用 set()方法设置一些属性值。</p><p class='p small'>4、如果Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。</p><p class='p small'>5、如果Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</p><p class='p small'>6、如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</p><p class='p small'>7、与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</p><p class='p small'>8、 如果有和加载这个 Bean 的 Spring 容器相关的BeanPostProcessor 对象，执行postProcessBeforeInitialization()方法</p><p class='p small'>9、如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</p><p class='p small'>10、如果Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</p><p class='p small'>11、如果有和加载这个 Bean的 Spring 容器相关的BeanPostProcessor 对象，执行postProcessAfterInitialization()方法</p><p class='p small'>12、当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</p><p class='p small'>13、当要销毁 Bean 的时候，如果 Bean在配置文件中的定义destroy-method 属性，执行指定的方法。</p><br/><p><strong><p class='p small'>7、 解释 Spring 支持的几种 bean 的作用域。</p></strong></p><p class='p small'>Spring 容器中的 bean 可以分为 5 个范围：</p><p class='p small'>（1）singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。</p><p class='p small'>（2）prototype：为每一个 bean 请求提供一个实例。</p><p class='p small'>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。</p><p class='p small'>（4）session：与request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</p><p class='p small'>（5）global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与Servlet 中的 session 作用域效果相同</p> <br/><p><strong><p class='p small'>8、Spring 框架中的单例 Beans 是线程安全的么？</p></strong></p><p class='p small'>Spring 框架并没有对单例 bean 动行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。</p> <br/><p><strong><p class='p small'>9、Spring 如何处理线程并发问题？</p></strong></p><p class='p small'>在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 动行处理，解决线程安全问题。ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的 方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时 间”的方式。</p><p class='p small'>ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程 都拥有自己的变量副本，从而也就没有必要对该变量动行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程 代码时，可以把不安全的变量封装动 ThreadLocal。</p> <br/><p><strong><p class='p small'>10-1、Spring 基于 xml 注入bean 的几种方式：</p></strong></p><p class='p small'>平常的 Java 开发中，程序员在某个类中需要依赖其它类的方法。通常是 new 一个依赖类的实例再调用该实例的方 法，这种开发存在的问题是new 的类实例不好统一管理。</p><p class='p small'>Spring 提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过 Spring 容器帮我们 new 指定实例并且将实例注入 到需要该对象的类中。依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们 new 一个实例，这个实例的控制 权是我们程序员。而控制反转是指 new 实例工作不由我们程序员来做而是交给 Spring 容器来做。Spring 有多种依赖注入 的形式</p><p><strong><p class='p small'>（1） Set 方法注入；</p></strong></p><p><strong><p class='p small'>（2）极造器注入：①通过 index 设置参数的位置；②通过 type 设置参数类型；</p></strong></p><p><strong><p class='p small'>（3）静态工厂注入；</p></strong></p><p><strong><p class='p small'>（4）实例工厂；</p></strong></p><br/><p><strong><p class='p small'>10-2、Spring 的自动装配：</p></strong></p><p class='p small'>在 Spring 框架 xml 配置中共有 5 种自动装配：</p><p class='p small'>（1）no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。</p><p class='p small'>（2）byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 不另一bean 的 name 相同，就进行自动 装配。</p><p class='p small'>（3）byType：通过参数的数据类型进行自动装配。</p><p class='p small'>（4）constructor：利用极造函数进行装配，并且极造函数的参数通过 byType 进行装配。</p><p class='p small'>（5）autodetect：自动探测，如果有极造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。</p><p class='p small'>基于注解的方式：</p><p class='p small'>使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置，<context:annotation-config />。在吭动 spring IoC 时，容器自动装载了一个 AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该 对象的属性。在使用@Autowired 时，首先在容器中查询对应类型的 bean：</p><p><strong><p class='p small'>如果查询结果刚好为一个，就将该bean 装配给@Autowired 指定的数据；</p></strong></p><p><strong><p class='p small'>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p></strong></p><p><strong><p class='p small'>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用 required=false。</p></strong></p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ集群</title>
      <link href="/buffifly/2021/07/10/%E9%9B%86%E7%BE%A4/"/>
      <url>/buffifly/2021/07/10/%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h2><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><p class='p small'>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键</p><br/><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p><strong><p class='p small'>1.修改 3 台机器的主机名称</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure><p class='p small'>分别修改为node1，node2，node3</p><p><strong><p class='p small'>2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.186.110 node1</span><br><span class="line">192.168.186.111 node2</span><br><span class="line">192.168.186.112 node3</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>3.以确保各个节点的 cookie 文件使用的是同一个值</p></strong></p><p class='p small'>在 node1 上执行远程操作命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</span><br><span class="line">scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node3:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>4.启动 RabbitMQ 服务</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>5.在节点2 分别执行</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>6.在节点 3 分别执行</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>7.查看集群状态</p></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p><strong><p class='p small'>8.需要重新设置用户</p></strong></p><p class='p small'>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123123</span><br></pre></td></tr></table></figure><p class='p small'>设置用户角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p class='p small'>设置用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><br/><h3 id="如何解除集群节点-node2-和-node3-机器分别执行"><a href="#如何解除集群节点-node2-和-node3-机器分别执行" class="headerlink" title="如何解除集群节点(node2 和 node3 机器分别执行)"></a>如何解除集群节点(node2 和 node3 机器分别执行)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试题总结</title>
      <link href="/buffifly/2021/07/08/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/buffifly/2021/07/08/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="Q1：MySQL-的逻辑架构了解吗？"><a href="#Q1：MySQL-的逻辑架构了解吗？" class="headerlink" title="Q1：MySQL 的逻辑架构了解吗？"></a>Q1：MySQL 的逻辑架构了解吗？</h2><p class='p small'>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。</p><p class='p small'>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</p><p class='p small'>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p><br/><h2 id="Q2：谈一谈-MySQL-的读写锁"><a href="#Q2：谈一谈-MySQL-的读写锁" class="headerlink" title="Q2：谈一谈 MySQL 的读写锁"></a>Q2：谈一谈 MySQL 的读写锁</h2><p class='p small'>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p><p class='p small'>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。</p><br/><h2 id="Q3：MySQL-的锁策略有什么？"><a href="#Q3：MySQL-的锁策略有什么？" class="headerlink" title="Q3：MySQL 的锁策略有什么？"></a>Q3：MySQL 的锁策略有什么？</h2><p class='p small'>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。</p><p class='p small'>行锁可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。</p><br/><h2 id="Q4：数据库死锁如何解决？"><a href="#Q4：数据库死锁如何解决？" class="headerlink" title="Q4：数据库死锁如何解决？"></a>Q4：数据库死锁如何解决？</h2><p class='p small'>死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资源时也会产生死锁。</p><p class='p small'>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持有最少行级排它锁的事务进行回滚。</p><p class='p small'>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p><br/><h2 id="Q5：事务是什么"><a href="#Q5：事务是什么" class="headerlink" title="Q5：事务是什么?"></a>Q5：事务是什么?</h2><p class='p small'>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。</p><br/><h2 id="Q6：事务有什么特性？"><a href="#Q6：事务有什么特性？" class="headerlink" title="Q6：事务有什么特性？"></a>Q6：事务有什么特性？</h2><p><strong><p class='p small'>原子性 atomicity</p></strong></p><p class='p small'>一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。</p><p><strong><p class='p small'>一致性 consistency</p></strong></p><p class='p small'>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p><p><strong><p class='p small'>隔离性 isolation</p></strong></p><p class='p small'>针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong><p class='p small'>持久性 durability</p></strong></p><p class='p small'>一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p><br/><h2 id="Q7：MySQL-的隔离级别有哪些？"><a href="#Q7：MySQL-的隔离级别有哪些？" class="headerlink" title="Q7：MySQL 的隔离级别有哪些？"></a>Q7：MySQL 的隔离级别有哪些？</h2><p><strong><p class='p small'>未提交读 READ UNCOMMITTED</p></strong></p><p class='p small'>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有比其他级别好很多，很少使用。</p><p><strong><p class='p small'>提交读 READ COMMITTED</p></strong></p><p class='p small'>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能"看见"已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。</p><p><strong><p class='p small'>可重复读 REPEATABLE READ</p></strong>（MySQL默认的隔离级别）</p><p class='p small'>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。</p><p><strong><p class='p small'>可串行化 SERIALIZABLE</p></strong></p><p class='p small'>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。</p><br/><h2 id="Q8：MVCC-是什么？"><a href="#Q8：MVCC-是什么？" class="headerlink" title="Q8：MVCC 是什么？"></a>Q8：MVCC 是什么？</h2><p class='p small'>MVCC 是多版本并发控制，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p class='p small'>InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p class='p small'>MVCC 只能在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作，因为 `READ UNCOMMITTED` 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 `SERIALIZABLE` 则会对所有读取的行都加锁。</p><br/><h2 id="Q9：谈一谈-InnoDB"><a href="#Q9：谈一谈-InnoDB" class="headerlink" title="Q9：谈一谈 InnoDB"></a>Q9：谈一谈 InnoDB</h2><p class='p small'>InnoDB 是 MySQL 的默认事务型引擎，用来处理大量短期事务。InnoDB 的性能和自动崩溃恢复特性使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB。</p><p class='p small'>InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。</p><p class='p small'>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 `REPEATABLE READ`，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p><p class='p small'>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。</p><p class='p small'>InnoDB 的存储格式是平***立的，可以将数据和索引文件从一个平台复制到另一个平台。</p><p class='p small'>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><br/><h2 id="Q10：谈一谈-MyISAM"><a href="#Q10：谈一谈-MyISAM" class="headerlink" title="Q10：谈一谈 MyISAM"></a>Q10：谈一谈 MyISAM</h2><p class='p small'>MySQL5.1及之前，MyISAM 是默认存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。</p><p class='p small'>MyISAM 将表存储在数据文件和索引文件中，分别以 `.MYD` 和 `.MYI` 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。</p><p class='p small'>MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。</p><p class='p small'>对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。</p><p class='p small'>对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p><p class='p small'>MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。</p><br/><h2 id="Q11：谈一谈-Memory"><a href="#Q11：谈一谈-Memory" class="headerlink" title="Q11：谈一谈 Memory"></a>Q11：谈一谈 Memory</h2><p class='p small'>如果需要快速访问数据且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有数据都保存在内存，不需要磁盘 IO，Memory 表的结构在重启后会保留，但数据会丢失。</p><p class='p small'>Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存数据分析中产生的中间数据。</p><p class='p small'>Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。</p><p class='p small'>如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。</p><br/><h2 id="Q12：查询执行流程是什么？"><a href="#Q12：查询执行流程是什么？" class="headerlink" title="Q12：查询执行流程是什么？"></a>Q12：查询执行流程是什么？</h2><p class='p small'>简单来说分为五步： ① 客户端发送一条查询给服务器。 ② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。 ③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。 ④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。 ⑤ 将结果返回给客户端。</p><br/><h2 id="Q13：VARCHAR-和-CHAR-的区别？"><a href="#Q13：VARCHAR-和-CHAR-的区别？" class="headerlink" title="Q13：VARCHAR 和 CHAR 的区别？"></a>Q13：VARCHAR 和 CHAR 的区别？</h2><p class='p small'>VARCHAR用于存储可变字符串，是最常见的字符串数据类型。它比 CHAR 更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1 或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要 1 字节。VARCHAR 不会删除末尾空格。</p><p class='p small'>VARCHAR 适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。</p><p class='p small'>CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。</p><p class='p small'>CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。</p><br/><h2 id="Q14：DATETIME-和-TIMESTAMP-的区别？"><a href="#Q14：DATETIME-和-TIMESTAMP-的区别？" class="headerlink" title="Q14：DATETIME 和 TIMESTAMP 的区别？"></a>Q14：DATETIME 和 TIMESTAMP 的区别？</h2><p class='p small'>DATETIME能保存大范围的值，从 1001~9999 年，精度为秒。把日期和时间封装到了一个整数中，与时区无关，使用 8 字节存储空间。</p><p class='p small'>TIMESTAMP 和 UNIX 时间戳相同，只使用 4 字节的存储空间，范围比 DATETIME 小得多，只能表示 1970 ~2038 年，并且依赖于时区。</p><br/><h2 id="Q15：数据类型有哪些优化策略？"><a href="#Q15：数据类型有哪些优化策略？" class="headerlink" title="Q15：数据类型有哪些优化策略？"></a>Q15：数据类型有哪些优化策略？</h2><p><strong><p class='p small'>更小的通常更好</p></strong></p><p class='p small'>一般情况下尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常也更快，因为它们占用更少的磁盘、内存和 CPU 缓存。</p><p><strong><p class='p small'>尽可能简单</p></strong></p><p class='p small'>简单数据类型的操作通常需要更少的 CPU 周期，例如整数比字符操作代价更低，因为字符集和校对规则使字符相比整形更复杂。应该使用 MySQL 的内建类型 date、time 和 datetime 而不是字符串来存储日期和时间，另一点是应该使用整形存储 IP 地址。</p><p><strong><p class='p small'>尽量避免 NULL</p></strong></p><p class='p small'>通常情况下最好指定列为 NOT NULL，除非需要存储 NULL值。因为如果查询中包含可为 NULL 的列对 MySQL 来说更难优化，可为 NULL 的列使索引、索引统计和值比较都更复杂，并且会使用更多存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外字节，在MyISAM 中还可能导致固定大小的索引变成可变大小的索引。</p><p class='p small'>如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。</p><br/><h2 id="Q16：索引有什么作用？"><a href="#Q16：索引有什么作用？" class="headerlink" title="Q16：索引有什么作用？"></a>Q16：索引有什么作用？</h2><p class='p small'>索引也叫键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</p><p class='p small'>索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免排序和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。</p><p class='p small'>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能使用索引的最左前缀。</p><br/><h2 id="Q17：谈一谈-MySQL-的-B-Tree-索引"><a href="#Q17：谈一谈-MySQL-的-B-Tree-索引" class="headerlink" title="Q17：谈一谈 MySQL 的 B-Tree 索引"></a>Q17：谈一谈 MySQL 的 B-Tree 索引</h2><p class='p small'>大多数 MySQL 引擎都支持这种索引，但底层的存储引擎可能使用不同的存储结构，例如 NDB 使用 T-Tree，而 InnoDB 使用 B+ Tree。</p><p class='p small'>B-Tree 通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。</p><p class='p small'>B-Tree索引的限制：</p><ul><li><p class='p small'>如果不是按照索引的最左列开始查找，则无法使用索引。</p></li><li><p class='p small'>不能跳过索引中的列，例如索引为 (id，name，sex)，不能只使用 id 和 sex 而跳过 name。</p></li><li><p class='p small'>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</p></li></ul><br/><h2 id="Q18：了解-Hash-索引吗？"><a href="#Q18：了解-Hash-索引吗？" class="headerlink" title="Q18：了解 Hash 索引吗？"></a>Q18：了解 Hash 索引吗？</h2><p class='p small'>哈希索引基于[哈希表](https://www.cxyxiaowu.com/7741.html)实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在[哈希表](https://www.cxyxiaowu.com/7741.html)中保存指向每个数据行的指针。</p><p class='p small'>只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。</p><p class='p small'>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：</p><ul><li><p class='p small'>哈希索引数据不是按照索引值顺序存储的，无法用于排序。</p></li><li><p class='p small'>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a，b)上建立哈希索引，如果查询的列只有a就无法使用该索引。</p></li><li><p class='p small'>哈希索引只支持等值比较查询，不支持任何范围查询。</p></li></ul><br/><h2 id="Q19：什么是自适应哈希索引？"><a href="#Q19：什么是自适应哈希索引？" class="headerlink" title="Q19：什么是自适应哈希索引？"></a>Q19：什么是自适应哈希索引？</h2><p class='p small'>自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</p><br/><h2 id="Q20-：什么是空间索引？"><a href="#Q20-：什么是空间索引？" class="headerlink" title="Q20 ：什么是空间索引？"></a>Q20 ：什么是空间索引？</h2><p class='p small'>MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。</p><br/><h2 id="Q21：什么是全文索引？"><a href="#Q21：什么是全文索引？" class="headerlink" title="Q21：什么是全文索引？"></a>Q21：什么是全文索引？</h2><p class='p small'>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><p class='p small'>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的"文档指针"。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p><br/><h2 id="Q22：什么是聚簇索引？"><a href="#Q22：什么是聚簇索引？" class="headerlink" title="Q22：什么是聚簇索引？"></a>Q22：什么是聚簇索引？</h2><p class='p small'>聚簇索引不是一种索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p class='p small'>优点：① 可以把相关数据保存在一起。② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p><p class='p small'>缺点：① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。② 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。③ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</p><br/><h2 id="Q23：什么是覆盖索引？"><a href="#Q23：什么是覆盖索引？" class="headerlink" title="Q23：什么是覆盖索引？"></a>Q23：什么是覆盖索引？</h2><p class='p small'>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p><p class='p small'>优点：① 索引条目通常远小于数据行大小，可以极大减少数据访问量。② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</p><br/><h2 id="Q24：你知道哪些索引使用原则？"><a href="#Q24：你知道哪些索引使用原则？" class="headerlink" title="Q24：你知道哪些索引使用原则？"></a>Q24：你知道哪些索引使用原则？</h2><p><strong><p class='p small'>建立索引</p></strong></p><p class='p small'>对查询频次较高且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，应当挑选最常用、过滤效果最好的列的组合。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p><p><strong><p class='p small'>使用前缀索引</p></strong></p><p class='p small'>索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p><p><strong><p class='p small'>选择合适的索引顺序</p></strong></p><p class='p small'>当不需要考虑排序和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。</p><p><strong><p class='p small'>删除无用索引</p></strong></p><p class='p small'>MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A，B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p><br/><h2 id="Q25：索引失效的情况有哪些？"><a href="#Q25：索引失效的情况有哪些？" class="headerlink" title="Q25：索引失效的情况有哪些？"></a>Q25：索引失效的情况有哪些？</h2><p class='p small'>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p><p class='p small'>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</p><p class='p small'>MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做比较。这种情况下 MySQL 只能提取数据行的值而不是索引值来做比较。</p><p class='p small'>如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。</p><p class='p small'>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。</p><p class='p small'>如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p><p class='p small'>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><br/><h2 id="Q26：如何定位低效-SQL？"><a href="#Q26：如何定位低效-SQL？" class="headerlink" title="Q26：如何定位低效 SQL？"></a>Q26：如何定位低效 SQL？</h2><p class='p small'>可以通过两种方式来定位执行效率较低的 SQL 语句。一种是通过慢查询日志定位，可以通过慢查询日志定位那些已经执行完毕的 SQL 语句。另一种是使用 SHOW PROCESSLIST 查询，慢查询日志在查询结束以后才记录，所以在应用反应执行效率出现问题的时候查询慢查询日志不能定位问题，此时可以使用 SHOW PROCESSLIST 命令查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实时查看 SQL 的执行情况，同时对一些锁表操作进行优化。找到执行效率低的 SQL 语句后，就可以通过 SHOW PROFILE、EXPLAIN 或 trace 等丰富来继续优化语句。</p><br/><h2 id="Q27：SHOW-PROFILE-的作用？"><a href="#Q27：SHOW-PROFILE-的作用？" class="headerlink" title="Q27：SHOW PROFILE 的作用？"></a>Q27：SHOW PROFILE 的作用？</h2><p class='p small'>通过 SHOW PROFILE 可以分析 SQL 语句性能消耗，例如查询到 SQL 会执行多少时间，并显示 CPU、内存使用量，执行过程中系统锁及表锁的花费时间等信息。例如 `SHOW PROFILE CPU/MEMORY/BLOCK IO FOR QUERY N` 分别查询 id 为 N 的 SQL 语句的 CPU、内存以及 IO 的消耗情况。</p><br/><h2 id="Q28：trace-是干什么的？"><a href="#Q28：trace-是干什么的？" class="headerlink" title="Q28：trace 是干什么的？"></a>Q28：trace 是干什么的？</h2><p class='p small'>从 MySQL5.6 开始，可以通过 trace 文件进一步获取优化器是是如何选择执行计划的，在使用时需要先打开设置，然后执行一次 SQL，最后查看 information_schema.optimizer_trace 表而都内容，该表为联合i表，只能在当前会话进行查询，每次查询后返回的都是最近一次执行的 SQL 语句。</p><br/><h2 id="Q29：EXPLAIN-的字段有哪些，具有什么含义？"><a href="#Q29：EXPLAIN-的字段有哪些，具有什么含义？" class="headerlink" title="Q29：EXPLAIN 的字段有哪些，具有什么含义？"></a>Q29：EXPLAIN 的字段有哪些，具有什么含义？</h2><p class='p small'>执行计划是 SQL 调优的一个重要依据，可以通过 EXPLAIN 命令查看 SQL 语句的执行计划，如果作用在表上，那么该命令相当于 DESC。EXPLAIN 的指标及含义如下：</p><table><thead><tr><th>指标名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>表示 SELECT 子句或操作表的顺序，执行顺序从大到小执行，当 id 一样时，执行顺序从上往下。</td></tr><tr><td>select_type</td><td>表示查询中每个 SELECT 子句的类型，例如 SIMPLE 表示不包含子查询、表连接或其他复杂语法的简单查询，PRIMARY 表示复杂查询的最外层查询，SUBQUERY 表示在 SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>type</td><td>表示访问类型，性能由差到好为：ALL 全表扫描、index 索引全扫描、range 索引范围扫描、ref 返回匹配某个单独值得所有行，常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找，也经常出现在 join 操作中、eq_ref 唯一性索引扫描，对于每个索引键只有一条记录与之匹配、const 当 MySQL 对查询某部分进行优化，并转为一个常量时，使用这些访问类型，例如将主键或唯一索引置于 WHERE 列表就能将该查询转为一个 const、system 表中只有一行数据或空表，只能用于 MyISAM 和 Memory 表、NULL 执行时不用访问表或索引就能得到结果。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</td></tr><tr><td>possible_keys</td><td>表示查询时可能用到的索引，但不一定使用。列出大量可能索引时意味着备选索引数量太多了。</td></tr><tr><td>key</td><td>显示 MySQL 在查询时实际使用的索引，如果没有使用则显示为 NULL。</td></tr><tr><td>key_len</td><td>表示使用到索引字段的长度，可通过该列计算查询中使用的索引的长度，对于确认索引有效性以及多列索引中用到的列数目很重要。</td></tr><tr><td>ref</td><td>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</td></tr><tr><td>rows</td><td>表示 MySQL 根据表统计信息及索引选用情况，估算找到所需记录所需要读取的行数。</td></tr><tr><td>Extra</td><td>表示额外信息，例如 Using temporary 表示需要使用临时表存储结果集，常见于排序和分组查询。Using filesort 表示无法利用索引完成的文件排序，这是 ORDER BY 的结果，可以通过合适的索引改进性能。Using index 表示只需要使用索引就可以满足查询表得要求，说明表正在使用覆盖索引。</td></tr></tbody></table><br/><h2 id="Q30：有哪些优化-SQL-的策略？"><a href="#Q30：有哪些优化-SQL-的策略？" class="headerlink" title="Q30：有哪些优化 SQL 的策略？"></a>Q30：有哪些优化 SQL 的策略？</h2><p><strong><p class='p small'>优化 COUNT 查询</p></strong></p><p class='p small'>COUNT 是一个特殊的函数，它可以统计某个列值的数量，在统计列值时要求列值是非空的，不会统计 NULL 值。如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。</p><p class='p small'>COUNT 的另一个作用是统计结果集的行数，当 MySQL 确定括号内的表达式不可能为 NULL 时，实际上就是在统计行数。当使用 COUNT(*) 时，\* 不会扩展成所有列，它会忽略所有的列而直接统计所有的行数。</p><p class='p small'>某些业务场景并不要求完全精确的 COUNT 值，此时可以使用近似值来代替，EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，因为执行 EXPLAIN 并不需要真正地执行查询。</p><p class='p small'>通常来说 COUNT 都需要扫描大量的行才能获取精确的结果，因此很难优化。在 MySQL 层还能做的就只有覆盖扫描了，如果还不够就需要修改应用的架构，可以增加汇总表或者外部缓存系统。</p><p><strong><p class='p small'>优化关联查询</p></strong></p><p class='p small'>确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p><p class='p small'>确保任何 GROUP BY 和 ORDER BY 的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化这个过程。</p><p class='p small'>在 MySQL 5.5 及以下版本尽量避免子查询，可以用关联查询代替，因为执行器会先执行外部的 SQL 再执行内部的 SQL。</p><p><strong><p class='p small'>优化 GROUP BY</p></strong></p><p class='p small'>如果没有通过 ORDER BY 子句显式指定要[排序](https://www.cxyxiaowu.com/11390.html)的列，当查询使用 GROUP BY 时，结果***自动按照分组的字段进行[排序](https://www.cxyxiaowu.com/11390.html)，如果不关心结果集的顺序，可以使用 ORDER BY NULL 禁止[排序](https://www.cxyxiaowu.com/11390.html)。</p><p><strong><p class='p small'>优化 LIMIT 分页</p></strong></p><p class='p small'>在偏移量非常大的时候，需要查询很多条数据再舍弃，这样的代价非常高。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。最简单的办法是尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p><p class='p small'>还有一种方法是从上一次取数据的位置开始扫描，这样就可以避免使用 OFFSET。其他优化方法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做[排序](https://www.cxyxiaowu.com/11390.html)的数据列。</p><p><strong><p class='p small'>优化 UNION 查询</p></strong></p><p class='p small'>MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。</p><p><strong><p class='p small'>使用用户自定义变量</p></strong></p><p class='p small'>在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在，可以在任何可以使用表达式的地方使用自定义变量。例如可以使用变量来避免重复查询刚刚更新过的数据、统计更新和插入的数量等。</p><p><strong><p class='p small'>优化 INSERT</p></strong></p><p class='p small'>需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句，这种方式将缩减客户端与数据库之间的连接、关闭等消耗，效率比多条插入单个值的 INSERT 语句高。也可以关闭事务的自动提交，在插入完数据后提交。当插入的数据是按主键的顺序插入时，效率更高。</p><br/><h2 id="Q31：MySQL-主从复制的作用？"><a href="#Q31：MySQL-主从复制的作用？" class="headerlink" title="Q31：MySQL 主从复制的作用？"></a>Q31：MySQL 主从复制的作用？</h2><p class='p small'>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。</p><p class='p small'>MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p><p class='p small'>MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。</p><p class='p small'>复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。</p><br/><h2 id="Q32：MySQL-主从复制的步骤？"><a href="#Q32：MySQL-主从复制的步骤？" class="headerlink" title="Q32：MySQL 主从复制的步骤？"></a>Q32：MySQL 主从复制的步骤？</h2><p class='p small'>① 在主库上把数据更改记录到二进制日志中。</p><p class='p small'>② 备库将主库的日志复制到自己的中继日志中。</p><p class='p small'>③ 备库读取中继日志中的事件，将其重放到备库数据之上。</p><p class='p small'>第一步是在主库上记录二进制日志，每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p><p class='p small'>下一步，备库将主库的二进制日志复制到其本地的中继日志中。备库首先会启动一个工作的 IO 线程，IO 线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库 IO 线程会将接收到的事件记录到中继日志中。</p><p class='p small'>备库的 SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当 SQL 线程追赶上 IO 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL 线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。</p><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的五大数据类型及操作命令</title>
      <link href="/buffifly/2021/07/07/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/buffifly/2021/07/07/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="Redis的五大数据类型及常用命令"><a href="#Redis的五大数据类型及常用命令" class="headerlink" title="Redis的五大数据类型及常用命令"></a>Redis的五大数据类型及常用命令</h2><h3 id=""><a href="#" class="headerlink" title=""></a><p class='p small'>Redis 键(key) 的常用命令</p></h3><p class='p small'>该命令用在key存在时删除key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Del key</span><br></pre></td></tr></table></figure><p class='p small'>序列化给定key，并返回被序列化的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DUMP key</span><br></pre></td></tr></table></figure><p class='p small'>检查给定的key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS key</span><br></pre></td></tr></table></figure><p class='p small'>为给定key设置过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure><p class='p small'>EXPIREAT的作用和EXPIRE类似，都用于为key设置过期时间，不同在于EXPIREAT命令接受的时间参数是时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure><p class='p small'>设置key的过期时间以毫秒计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure><p class='p small'>查找所以符合给定模式的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure><p class='p small'>将当前数据库的key移动到给定的数据库db当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVE key db</span><br></pre></td></tr></table></figure><p class='p small'>移除key的过期时间，key将持久保持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSIST key</span><br></pre></td></tr></table></figure><p class='p small'>以毫秒为单位返回key的剩余过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTTL key</span><br></pre></td></tr></table></figure><p class='p small'>以秒为单位返回key的剩余过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL key</span><br></pre></td></tr></table></figure><p class='p small'>从当前库中随机返回一个key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANDOMKEY</span><br></pre></td></tr></table></figure><p class='p small'>修改key的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME key newkey</span><br></pre></td></tr></table></figure><p class='p small'>返回key所储存值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure><br/><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><p class='p small'>String（字符串）</p></h3><p class='p small'>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value，String类型是二进制安全的，意思是Redis的String可以包含任何数据，比如jpg图片或者序列化的对象</p><p><strong><p class='p small'>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p></strong></p><h4 id="Redis中String的常用命令"><a href="#Redis中String的常用命令" class="headerlink" title="Redis中String的常用命令"></a>Redis中String的常用命令</h4><p class='p small'>设置指定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure><p class='p small'>获取指定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><p class='p small'>获返回key中字符串值的子字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETRANGE key start end</span><br></pre></td></tr></table></figure><p class='p small'>将给定的key的值设为value，并返回key的旧值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><p class='p small'>对key所存储的字符串值，获取指定偏移量上的位（bit）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure><p class='p small'>获取一个或多个给定key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key1 key2 key3......</span><br></pre></td></tr></table></figure><p class='p small'>对key所存储的字符串值，设置或清除指定偏移量上的位（bit）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure><p class='p small'>只有在key不存在时设置key的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p class='p small'>将值value关联到key，并设置key的过期时间（秒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br></pre></td></tr></table></figure><p class='p small'>返回key所存储的字符串值的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p class='p small'>同时设置多个key value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>同时设置一个或者多个键值对，仅当前所有key都不存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSETNX k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>以毫秒为单位设置key的生存时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSETEX key milliseconds value</span><br></pre></td></tr></table></figure><p class='p small'>将key中存储的数字值增1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值加上给定的增量值（inceement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key inceement</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值加上给定的浮点增量值（inceement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><p class='p small'>将key中存储的数字减一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure><p class='p small'>将key所存储的值减去给定的减量值（decrement）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><p class='p small'>如果key存在并且是一个字符串，将值追加到key的末尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><br/><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><p class='p small'>Hash（哈希，类似java里的Map）</p></h3><p class='p small'>Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p class='p small'>类似Java里面的Map<String</p><p class='p small'>删除一个或多个哈西表字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key fieId2 field2.....</span><br></pre></td></tr></table></figure><p class='p small'>查看哈西表key中，指定的字段是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p class='p small'>获取存储在哈希表中指定字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p class='p small'>获取在哈希表中指定key的所有字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p class='p small'>为哈希表key中的指定字段的整数值加上增量increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure><p class='p small'>为哈希表key中的指定字段的浮点数值加上增量increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBYELOAT key field increment</span><br></pre></td></tr></table></figure><p class='p small'>获取所有哈希表中的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p class='p small'>获取哈希表中字段的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p class='p small'>获取所有给定字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field1 field2</span><br></pre></td></tr></table></figure><p class='p small'>同时将多个field-value对设置到哈希表key中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key firld1 value1 firld2 value2</span><br></pre></td></tr></table></figure><p class='p small'>将哈希表key中的字段firld的值设value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key firld value</span><br></pre></td></tr></table></figure><p class='p small'>只有在字段field不存在时，设置哈希表字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key firld value</span><br></pre></td></tr></table></figure><p class='p small'>获取哈希表中所有值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p class='p small'>迭代哈希表中的键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><br/><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><p class='p small'>List（列表）</p></h3><p class='p small'>Redis 列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素导列表的头部（左边）或者尾部（右边）它的底层实际是个链表</p><p class='p small'>通过索引获取列表中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p class='p small'>在列表的元素前或后插入元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFOREIAFTER pivot value</span><br></pre></td></tr></table></figure><p class='p small'>获取列表长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p class='p small'>移出并获取列表的第一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br></pre></td></tr></table></figure><p class='p small'>将一个或多个值插入到列表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>将一个或多个值插入到已存在的列表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX k1 v1 k2 v2</span><br></pre></td></tr></table></figure><p class='p small'>获取列表指定范围内的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p class='p small'>移除列表元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></table></figure><p class='p small'>通过索引设置列表元素的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表最后一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p class='p small'>移除列表最后一个元素，并将该元素添加到另一个列表并返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure><p class='p small'>在列表中添加一个或多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key v1 v2 v3......</span><br></pre></td></tr></table></figure><p class='p small'>为已存在的列表添加值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSHX key value</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表第一个元素，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLPOP k1 k2 timeout</span><br></pre></td></tr></table></figure><p class='p small'>移除并获取列表最后一个元素，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP k1 k2 timeout</span><br></pre></td></tr></table></figure><p class='p small'>从列表弹出一个值，并将该元素插入到另一个列表中并返回他，如果没有则阻塞队列直到发现或等待超时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOPLPUSH source destination timeout</span><br></pre></td></tr></table></figure><br/><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><p class='p small'>Set（集合）</p></h3><p class='p small'>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的</p><p class='p small'>向集合添加一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 member2</span><br></pre></td></tr></table></figure><p class='p small'>获取集合的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key1 key2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的差集并存储在destination中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>返回给定所有集合的交集并存储在destination中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>判断member元素是否是集合key的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p class='p small'>返回集合中所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p class='p small'>将member元素从source集合移动到destination集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p class='p small'>移除并返回集合中一个随机元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></table></figure><p class='p small'>返回集合中一个或多个随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key count</span><br></pre></td></tr></table></figure><p class='p small'>移除集合中一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member1 member2</span><br></pre></td></tr></table></figure><p class='p small'>返回所有给定集合的并集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>所有给定集合的并集存储在destination集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE destination k1 k2</span><br></pre></td></tr></table></figure><p class='p small'>迭代集合中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSCAN key cursor [MATCH pattem][COUNT count]</span><br></pre></td></tr></table></figure><br/><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><p class='p small'>Zset(sorted set：有序集合)</p></h3><p class='p small'>Redis zset 和 set 一样也是string类型元素的集合</p><p class='p small'>Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的</p><p class='p small'>向有序集合添加一个或多个成员，或者更新已存在成员的分数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure><p class='p small'>获取有序集合的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p class='p small'>计算在有序集合中指定区间分数的成员数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p class='p small'>有序集合中对指定成员的分数加上增量 increment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p class='p small'>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><p class='p small'>在有序集合中计算指定字典区间内成员数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZLEXCOUNT key min max</span><br></pre></td></tr></table></figure><p class='p small'>通过索引区间返回有序集合指定区间内的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>通过字典区间返回有序集合的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br></pre></td></tr></table></figure><p class='p small'>通过分数返回有序集合指定区间内的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集合中指定成员的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中的一个或多个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的字典区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYLEX key min max</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的排名区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><p class='p small'>移除有序集合中给定的排名区间的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中指定区间内的成员，通过索引，分数从高到低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中指定分数区间内的成员，分数从高到低排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES]</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure><p class='p small'>返回有序集中，成员的分数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p class='p small'>计算给定的一个或多个有序集的并集，并存储在新的 key 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><p class='p small'>迭代有序集合中的元素（包括元素成员和元素分值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ安装教程及安装包</title>
      <link href="/buffifly/2021/07/05/RabbitMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/"/>
      <url>/buffifly/2021/07/05/RabbitMQ%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p class='p small'>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><br/><h2 id="RabbitMQ-的概念"><a href="#RabbitMQ-的概念" class="headerlink" title="RabbitMQ 的概念"></a>RabbitMQ 的概念</h2><p class='p small'>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><br/><h2 id="RabbitMQ四大核心概念"><a href="#RabbitMQ四大核心概念" class="headerlink" title="RabbitMQ四大核心概念"></a>RabbitMQ四大核心概念</h2><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p class='p small'>产生数据发送消息的程序是生产者</p><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p class='p small'>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p class='p small'>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p class='p small'>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者</p><h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><h5 id="1、下载RabbitMQ，官网地址"><a href="#1、下载RabbitMQ，官网地址" class="headerlink" title="1、下载RabbitMQ，官网地址"></a>1、下载RabbitMQ，官网地址</h5><p><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p><p class='p small'>博主链接：</p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/erlang-21.3-1.el7.x86_64.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/erlang-21.3-1.el7.x86_64.rpm</a></p><p><a href="https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/rabbitmq-server-3.8.8-1.el7.noarch.rpm" target="_blank" rel="noopener">https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p><h5 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h5><p class='p small'>上传到/usr/local/software 目录下(如果没有 software 需要自己创建)</p><img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0Liunx.png'><h5 id="3、安装文件-分别按照以下顺序安装"><a href="#3、安装文件-分别按照以下顺序安装" class="headerlink" title="3、安装文件(分别按照以下顺序安装)"></a>3、安装文件(分别按照以下顺序安装)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h5 id="4、常用命令-按照以下顺序执行"><a href="#4、常用命令-按照以下顺序执行" class="headerlink" title="4、常用命令(按照以下顺序执行)"></a>4、常用命令(按照以下顺序执行)</h5><p class='p small'>添加开机启动 RabbitMQ 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure><p class='p small'>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server start</span><br></pre></td></tr></table></figure><p class='p small'>查看服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server status</span><br></pre></td></tr></table></figure><img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/RabbitMQ%E7%8A%B6%E6%80%81.png'><p class='p small'>停止服务(选择执行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service rabbitmq-server stop</span><br></pre></td></tr></table></figure><p class='p small'>开启 web 管理插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p class='p small'>第一次用默认账号密码(guest)访问地址 http://127.0.0.1:15672/出现权限问题</p><img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%99%BB%E9%99%86%E5%87%BA%E7%8E%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98.png'><h5 id="5、添加一个新的用户"><a href="#5、添加一个新的用户" class="headerlink" title="5、添加一个新的用户"></a>5、添加一个新的用户</h5><p class='p small'>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin 123</span><br></pre></td></tr></table></figure><p class='p small'>设置用户角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p class='p small'>设置用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><p class='p small'>查看RabbitMQ中当前所有用户和角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h5 id="6、再次利用-admin-用户登录"><a href="#6、再次利用-admin-用户登录" class="headerlink" title="6、再次利用 admin 用户登录"></a>6、再次利用 admin 用户登录</h5><img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/img/RabbitMQ/%E5%86%8D%E6%AC%A1%E7%99%BB%E9%99%86RabbitMQ.png'><h5 id="7、重置命令"><a href="#7、重置命令" class="headerlink" title="7、重置命令"></a>7、重置命令</h5><p class='p small'>关闭应用的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure><p class='p small'>清除的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure><p class='p small'>重新启动命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7防火墙设置</title>
      <link href="/buffifly/2021/07/01/Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/"/>
      <url>/buffifly/2021/07/01/Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\buffifly\css\APlayer.min.css"><script src="\buffifly\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\buffifly\js\Meting.min.js"></script><h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><p class='p small'>查看已开放的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p class='p small'>开放端口（开放后需要要重启防火墙才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3338&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p class='p small'>关闭端口（关闭后需要要重启防火墙才生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --remove-port&#x3D;3338&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p class='p small'>重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p class='p small'>开机启动防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure><p class='p small'>开启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p class='p small'>禁止防火墙开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p class='p small'>停止防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><br/><h2 id="联系博主"><a href="#联系博主" class="headerlink" title="联系博主"></a>联系博主</h2><div class="btns circle center grid5">            <a href=''>  <i class="fa fa-apple"></i>  <b>微信</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%8D%9A%E4%B8%BB%E5%BE%AE%E4%BF%A1.png'></a><a href=''>  <i class="fa fa-apple"></i>  <b>公众号</b>  <img src= "/buffifly/img/loading.gif" data-src='https://lu-jia-chen.oss-cn-beijing.aliyuncs.com/lujiachen/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg'></a>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> Liunx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
